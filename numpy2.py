import numpy as np

a=np.arange(2,14).reshape((3,4))
print(a)
#[[ 2  3  4  5]
# [ 6  7  8  9]
# [10 11 12 13]]

print(np.argmin(a))#0，求矩阵中最小元素的索引
print(np.argmax(a))#11，求矩阵中最大元素的索引

print(np.mean(a))#计算统计中的均值，7.5
print(a.mean())

print(np.average(a))#计算统计中的均值，7.5

print(np.median(a))#求解中位数, 7.5


print(np.cumsum(a)) #累加函数，生成的每一项矩阵元素均是从原矩阵首项累加到对应项的元素之和。
#[ 2  5  9 14 20 27 35 44 54 65 77 90]


print(np.diff(a))#有累差运算函数：该函数计算的便是每一行中后一项与前一项之差。
#故一个3行4列矩阵通过函数计算得到的矩阵便是3行3列的矩阵。
'''
[[1 1 1]
 [1 1 1]
 [1 1 1]]
'''

print(np.nonzero(a)) #这个函数将所有非零元素的行与列坐标分割开，重构成两个分别关于行和列的矩阵。
#(array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]), array([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]))

b=np.arange(14,2,-1).reshape(3,4)
print(b)
'''
[[14 13 12 11]
 [10  9  8  7]
 [ 6  5  4  3]]
'''

print(np.sort(b)) #排序函数仅针对每一行进行从小到大排序操作
'''
[[11 12 13 14]
 [ 7  8  9 10]
 [ 3  4  5  6]]
'''

#矩阵的转置有两种表示方法
print(np.transpose(b))
print(b.T)
'''
[[14 10  6]
 [13  9  5]
 [12  8  4]
 [11  7  3]]
'''


print((b.T).dot(b))
'''转置后矩阵相乘：
[[332 302 272 242]
 [302 275 248 221]
 [272 248 224 200]
 [242 221 200 179]]
'''

print(b)
'''
[[14 13 12 11]
 [10  9  8  7]
 [ 6  5  4  3]]
'''
print(np.clip(b,5,9))
'''这个函数的格式是clip(Array,Array_min,Array_max)，
Array指的是将要被执行用的矩阵，而后面的最小值最大值则用于让函数
判断矩阵中元素是否有比最小值小的或者比最大值大的元素，
并将这些指定的元素转换为最小值或者最大值。

eg:
[[9 9 9 9]
 [9 9 8 7]
 [6 5 5 5]]
'''


print(b)
'''
[[14 13 12 11]
 [10  9  8  7]
 [ 6  5  4  3]]
'''
print(np.mean(b,axis=1)) #line
#[12.5  8.5  4.5]

print(np.mean(b,axis=0))#column
#[10.  9.  8.  7.]
